<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>Waiting Room + MQTT + JWT + PoP Test</title>

  <!-- MQTT.js -->
  <script src="https://unpkg.com/mqtt@5.5.0/dist/mqtt.min.js"></script>

  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    button { margin: 4px 0; width: 220px; }
    pre {
      background: #111;
      color: #0f0;
      padding: 10px;
      height: 280px;
      overflow: auto;
    }
  </style>
</head>
<body>

<h2>üéüÔ∏è Ticketing Waiting Room ‚Äì FULL TEST</h2>

<div>
  <button onclick="genVisitorToken1()">1Ô∏è‚É£ genVisitorToken</button><br/>
  <button onclick="enqueue()">2Ô∏è‚É£ Enqueue</button><br/>
  <button onclick="connectMqtt()">3Ô∏è‚É£ Connect MQTT</button><br/>
  <button onclick="disconnectMqtt()">üîå Disconnect MQTT</button><br/>
  <button onclick="issuePoP()">4Ô∏è‚É£ Issue PoP</button><br/>
  <button onclick="holdSeat()">5Ô∏è‚É£ Hold Seat</button>
</div>

<h3>Log</h3>
<pre id="log"></pre>

<script>
/* ================= CONFIG ================= */

const API_BASE = "http://localhost:9999";
const MQTT_WS_URL = "ws://192.168.1.100:8083/mqtt"; // EMQX WS
const EVENT_ID = "EVT_MULIV_2025";
const SEAT_ID = "A-10-05";

/* ================= STATE ================= */

let visitorToken = localStorage.getItem("visitorToken");
let accessToken = null;
let popToken = null;
let mqttClient = null;

/* ================= UTILS ================= */

function log(msg) {
  const el = document.getElementById("log");
  el.textContent += msg + "\n";
  el.scrollTop = el.scrollHeight;
}

function genVisitorToken() {
  return "vt_" + crypto.randomUUID();
}

function genVisitorToken1() {
  visitorToken = genVisitorToken();
  localStorage.setItem("visitorToken", visitorToken);
  log("‚û°Ô∏è visitorToken = " + visitorToken);
}

/* ================= STEP 1: ENQUEUE ================= */

async function enqueue() {
  if (!visitorToken) {
    visitorToken = genVisitorToken();
    localStorage.setItem("visitorToken", visitorToken);
  }

  log("‚û°Ô∏è Enqueue with visitorToken = " + visitorToken);

  const res = await fetch(`${API_BASE}/enqueue`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      eventId: EVENT_ID,
      visitorToken
    })
  });

  const data = await res.json();
  log("‚¨ÖÔ∏è Enqueue response: " + JSON.stringify(data));
}

/* ================= STEP 2: MQTT CONNECT ================= */

function connectMqtt() {
  if (!visitorToken) {
    alert("Enqueue first!");
    return;
  }

  if (mqttClient) {
    log("‚ö†Ô∏è MQTT already connected");
    return;
  }

  log("‚û°Ô∏è Connecting MQTT as " + visitorToken);

  mqttClient = mqtt.connect(MQTT_WS_URL, {
    clientId: visitorToken,
    username: "queue",
    password: "",
    clean: true,
    reconnectPeriod: 0
  });

  mqttClient.on("connect", () => {
    log("‚úÖ MQTT connected");

    const topic = `visitor/${visitorToken}`;
    mqttClient.subscribe(topic, () => {
      log("üì° Subscribed to " + topic);
    });
  });

  mqttClient.on("message", (topic, payload) => {
    const msg = JSON.parse(payload.toString());
    log("üì® MQTT message: " + JSON.stringify(msg));

    if (msg.accessToken) {
      accessToken = msg.accessToken;
      log("üîê accessToken received");
    }
  });

  mqttClient.on("close", () => {
    log("üîå MQTT connection closed");
  });

  mqttClient.on("error", err => {
    log("‚ùå MQTT error: " + err.message);
  });
}

/* ================= DISCONNECT MQTT ================= */

function disconnectMqtt() {
  if (!mqttClient) {
    log("‚ö†Ô∏è MQTT not connected");
    return;
  }

  const topic = `visitor/${visitorToken}`;

  try {
    mqttClient.unsubscribe(topic, () => {
      log("üì¥ Unsubscribed from " + topic);
    });

    mqttClient.end(true, () => {
      log("üîå MQTT disconnected");
    });
  } catch (e) {
    log("‚ùå Disconnect error: " + e.message);
  } finally {
    mqttClient = null;
   // accessToken = null;
   // popToken = null;
  }
}

/* ================= STEP 3: ISSUE PoP ================= */

async function issuePoP() {
  if (!accessToken) {
    alert("No accessToken yet!");
    return;
  }

  log("‚û°Ô∏è Issue PoP");

  const res = await fetch(`${API_BASE}/api/pop/issue`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": "Bearer " + accessToken
    }
  });

  const data = await res.json();
  popToken = data.popToken;

  log("‚¨ÖÔ∏è PoP issued: " + popToken);
}

/* ================= STEP 4: HOLD SEAT ================= */

async function holdSeat() {
  if (!accessToken || !popToken) {
    alert("Need accessToken + popToken");
    return;
  }

  log("‚û°Ô∏è Hold seat " + SEAT_ID);

  try {
    const res = await fetch(`${API_BASE}/api/seat/hold`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": "Bearer " + accessToken,
        "X-PoP": popToken
      },
      body: JSON.stringify({
        eventId: EVENT_ID,
        seatId: SEAT_ID
      })
    });

    // üëâ ƒê·ªåC BODY D∆Ø·ªöI D·∫†NG TEXT (an to√†n cho error)
    const text = await res.text();

    // üëâ HTTP ERROR (401, 409, 403, 500...)
    if (!res.ok) {
      log(`‚ùå HOLD FAILED`);
      log(`   ‚Ü≥ HTTP ${res.status} ${res.statusText}`);
      log(`   ‚Ü≥ Response: ${text}`);
      return;
    }

    // üëâ OK
    const data = text ? text : {};
    log("‚úÖ Hold success: " + data);

  } catch (err) {
    // üëâ L·ªñI NETWORK / CORS / FETCH FAIL
    log("üî• FETCH ERROR: " + err.message);
  }
}
</script>

</body>
</html>
